{"./":{"url":"./","title":"About Poly Network","keywords":"","body":"Poly Network Poly Network is the world’s leading cross-chain interoperability protocol for heterogeneous chains, enhancing connections between ledgers by providing interoperability in Web 3.0. Its uniquely designed cross-chain bridge technology executes cross-chain transactions by deploying smart contracts on the source chain and enabling communication between heterogeneous chains, including the more popular public chains, right at the protocol layer. Poly Network has integrated over 18 blockchains, including Ethereum, BNB Chain, Polygon, Avalanche, Fantom, Arbitrum, Optimism, Metis, Boba, OEC, HECO, Neo, Ontology, Zilliqa, Gnosis Chain and etc. We provide Protocol for connecting new chains to the poly cross-chain ecosystem Protocol for registering new cross-chain tokens Protocol for building your bridges Specification for customizing business logic contracts Poly dApps @[Token assets Cross-chain transfer]{https://bridge.poly.network/} resources/asset.svg \"rect\" @[NFT cross-chain transfer]{https://bridge.poly.network/nft} resources/nft.svg \"rect\" @[Token Swap]{https://o3swap.com/} resources/swap.svg \"rect\" Join the Community @[Telegram]{https://t.me/polynetworkgroup} resources/Telegram.png \"rect\" @[Discord]{https://discord.com/invite/y6MuEnq} resources/Discord.png \"rect\" @[Medium]{https://polynetwork.medium.com/} resources/Medium.png \"rect\" @[Github]{https://github.com/polynetwork} resources/GitHub.png \"rect\" @[Twitter]{https://twitter.com/PolyNetwork2} resources/Twitter.png \"rect\" @[Youtube]{https://www.youtube.com/channel/UC4vFRyVgvK7RnlkkLDmp23w/featured} resources/youtube.png \"rect\" Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 10:13:25 "},"guideline.html":{"url":"guideline.html","title":"Guidelines for Reading","keywords":"","body":"Guidelines for Reading Similar to any other cross-chain service, the accession to Poly cross-chain ecosystem will vary from section to section depending on your specific needs. Here we presuppose four major goals and provide corresponding tutorials for you to realize your goals. You can either click the quick guide below directly or follow the menu in the navigation. Add New Chains Please read this section if you want to connect your chain to Poly: Connect New Chains Build New Bridges Please read this section if you want to build a bridge using Poly Bridge sdk: Build New Bridges Import New Assets Please read this section if you want to import assets to the Poly cross-chain ecosystem: Import New Assets Customize Business Logic Contracts Please read this section if you want to deploy business contract: Customize Business Logic Contracts Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 10:13:25 "},"new_chain/readme.html":{"url":"new_chain/readme.html","title":"Connect New Chains","keywords":"","body":"Connect New Chains This section will be the most helpful tutorial if you want to import a new chain into the Poly cross-chain ecosystem. Before that, to help you better understand the necessary procedures, a flow chart is provided here. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 15:14:08 "},"new_chain/relay_chain/relay_chain_development.html":{"url":"new_chain/relay_chain/relay_chain_development.html","title":"Develop for Poly Chain","keywords":"","body":"Develop for Poly Chain 1. Requirements Before developing for Poly chain, you have to be prepared with the listed three prerequisites. 1.1 Light client verification The block header must contain the following information： Hash of the previous block header Merkle state root hash Necessary information to prove the legitimacy of the block header varies from different consensus mechanisms. [!Note|style:flat|label:Notice] If your chain doesn't support techniques like Simple Payment Verification (SPV) protocol in Bitcoin or Light Ethereum Subprotocol (LES) in Ethereum, get in touch with Poly team via for more support. 1.2 Block header structure and verification methods The following information is necessary： Block header structure Serialization and Deserialization methods Block header verification methods 1.3 Verifiable state root The following information is necessary： Merkle tree structure State root verification methods 2. Development Specifications With the prerequisites mentioned earlier, you can start developing methods for Poly chain following the guideline below from the perspective you need. 2.1 Synchronize block headers Block Header Synchronization Methods Method Description SyncGenesisHeader It stores and handles the initial block header so that the subsequent block headers of blocks that contain cross-chain events can be verified and synchronized. This method will only be called for once in initializing the new chain. Please refer to the code for more details. SyncBlockHeader It consistently synchronizes block cycle change and cross-chain transaction block headers from the new chain to the Poly chain. Please refer to the code for more details. Block Header Synchronization Entrance Method Method Description SyncSideChainGenesisHeader It is the entrance method for synchronizing the genesis block header of the new chain to Poly chain and synchronizing the genesis header of Poly chain to CCM contract of the new chain. Please refer to the code for more details. The key information for this method (submitted by .config): Service provider (endpoint) Url of the new chain. Genesis block height (Normally the latest. Essential information for verifying genesis headers may exist in header information already or need to be fetched from block headers from other block heights. Information required for the new chain block header verification. 2.2 Verify cross-chain transactions Cross Chain Management Method Description MakeDepositProposal It acts as the entrance of verifyFromTx, verifying, storing, and returning MakeTxParam for processing cross-chain steps, verifies cross-chain transactions, and stores legitimate transactions to the poly chain. Please refer to the code for more details. MakeDepositProposal: Requires: service *native.NativeService //Native Service that carries values of information of cross-chain events Returns: type verifyFromTx struct { TxHash []byte CrossChainId []byte //ChainId of source chain FromContractAddress uint64 //Cross Chain Management Contarct address of source chain ToChainId string //ChainId of target chain ToContractAddress uint64 //Cross Chain Management Contarct address of target chain Method []byte //Unlock or lock Args []byte } Method Description verifyFromTx It prepares block header and deserialized proof for verifyMerkleProof, decodes the extra data from tx, and constructs MakeTxParam. Please refer to the code for more details. verifyFromTx: Requires: service *native.NativeService proof []byte //the proof to be serialized and verified extra []byte //the transaction information that will be used for constructing verifyFromTx fromChainID uint64, //ChainId of source chain height uint32, //the block height corresponding to current transaction event sideChain *side_chain_manager.SideChain //source chain information that contains ccm contract address Returns: txParam *scom.MakeTxParam Method Description verifyMerkleProof It verifies the Merkle proof obtained by the relayer generated from the source chain to ensure that all transactions included in this block header have been created and can be seen on the Poly chain. Please refer to the code for details. verifyMerkleProof: Requires: blockData *types.Header //the blockheader corresponding to current transaction event proof []byte //the serialized proof Returns: Val []byte //the proof result for checking extra before constructing verifyFromTx Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:07:57 "},"new_chain/side_chain/contracts.html":{"url":"new_chain/side_chain/contracts.html","title":"Develop for New Chain","keywords":"","body":"Develop for New Chain The development of a new chain mainly involves developing cross-chain modules. Here, the cross-chain module works as a set of smart contracts. In some cases, it can also work as a native blockchain module. To help you develop it, here we offer examples in Solidity for each main method. You may refer to the complete code of these contracts. [!Note|style:flat|label:Notice] If the chain integrated to Poly Network supports EVM, you could freely use our cross-chain contracts as templates. If not, you may need to develop your contracts that contain the main features as shown in the following guidelines. 1. Introduction to Cross-chain Contracts In this part, we sort the contracts into data, logic, and proxy contracts to complete the cross-chain contracts. You could either follow the methods listed below or choose other ways for your project. List of contracts: Cross Chain Manager Contract: On the source chain, it creates the cross-chain transactions transferred to the Poly. The target chain verifies the legitimacy of transactions and executes the method on the target business logic contract. It may be referred to as a CCM contract in the following context. Cross Chain Data Contract: It serves as a database of cross-chain transactions. It may be referred to as a CCD contract in the following context. Cross Chain Manager Proxy Contract: It serves as a proxy of the CCM contract. When there is any need to upgrade the CCM contract, it would pause the old CCM contract and set the new CCM contract to the CCD contract. Business Logic Contract: It executes the business logic of cross-chain projects. It interacts with users and the CCM contract both on the source and target chains. We also offer the guidelines for developing a Business Logic Contract. Interactions among contracts 2. Developing CCM Contracts Before customizing your CCM, you need to implement the four main features. Step1. Synchronizing genesis block header This step is meant to implement the methods of synchronizing the genesis block header of the Poly chain to the CCM contract. Example: /* @notice Sync Poly chain genesis block header to smart contract * @dev This function can only be called once; nextbookkeeper of rawHeader can't be empty * @param rawHeader Poly chain genesis block raw header or raw Header including switching consensus peers info * @return true or false */ function initGenesisBlock(bytes memory rawHeader, bytes memory pubKeyList) whenNotPaused public returns(bool) { // Load Ethereum cross chain data contract IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // Make sure the contract has not been initialized before require(eccd.getCurEpochConPubKeyBytes().length == 0, \"EthCrossChainData contract has already been initialized!\"); // Parse header and convit the public keys into nextBookKeeper and compare it with header.nextBookKeeper to verify the validity of signature ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader); (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList); require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\"); // Record current epoch start height and public keys (by storing them in address format) require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\"); require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\"); // Fire the event emit InitGenesisBlockEvent(header.height, rawHeader); return true; } This method should be called initially and can only be called once. For the input data rawHeader, the nextbookkeeper can not be empty. Firstly, this function checks the public key of the current epoch to make sure that the CCM contract is uninitialized. Then we will parse the raw header to get the header.nextBookKeeper. Comparing it with the nextBookKeeper converted from pubKeyList, we could verify the validity of the signature. After verifying the signature, we could record the current epoch start height and the public keys by storing them in the address format. And then emit the event InitGenesisBlockEvent. Step2. Changing consensus validator This step is meant to implement the methods of changing the Poly Chain consensus validator, which is called BookKeeper in the code. Example: /* @notice change Poly chain consensus bookkeeper * @param rawHeader Poly chain change bookkeeper block raw header * @param pubKeyList Poly chain consensus nodes public key list * @param sigList Poly chain consensus nodes signature list * @return true or false */ function changeBookKeeper(bytes memory rawHeader, bytes memory pubKeyList, bytes memory sigList) whenNotPaused public returns(bool) { // Load Ethereum cross chain data contract ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader); IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // Make sure rawHeader.height is higher than recorded current epoch start height uint64 curEpochStartHeight = eccd.getCurEpochStartHeight(); require(header.height > curEpochStartHeight, \"The height of header is lower than current epoch start height!\"); // Ensure the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\"); // Verify signature of rawHeader comes from pubKeyList address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes()); uint n = polyChainBKs.length; require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\"); // Convert pubKeyList into Ethereum address format and make sure the compound address from the converted Ethereum addresses // equals passed in header.nextBookKeeper (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList); require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\"); // update current epoch start height of Poly chain and current epoch consensus peers book keepers addresses require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\"); require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\"); // Fire the change book keeper event emit ChangeBookKeeperEvent(header.height, rawHeader); return true; } Firstly, you need to make sure the rawHeader.height is higher than recorded current epoch starts height. Then you need to ensure that the rawHeader is the key header, including info of switching consensus peers by containing a non-empty nextBookKeeper field. Analogous to initGenesisBlock(), we also need to parse the raw header to get the header.nextBookKeeper. Comparing it with the nextBookKeeper converted from pubKeyList, we could verify the validity of the signature. After verifying the signature, we could record the current epoch start height and current epoch consensus peers bookkeepers by storing them in the address format. And then emit the event ChangeBookKeeperEvent. Step3. Pushing transactions This step is meant to implement the methods of pushing the serialized cross-chain transaction information to the Poly chain. Example: /* * @param toChainId The target chain id * @param toAddress The address in bytes format to receive the same amount of tokens in the target chain * @param toContract Target smart contract address in bytes in the target blockchain * @param txData Transaction data for target chain, include toAssetHash, toAddress, amount * @return true or false */ function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) { // Only allow whitelist contract to call require(whiteListFromContract[msg.sender],\"Invalid from contract\"); // Load Ethereum cross chain data contract IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // To help differentiate two txs, the ethTxHashIndex is increasing automatically uint256 txHashIndex = eccd.getEthTxHashIndex(); // Convert the uint256 into bytes bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex); // Construct the makeTxParam, and put the hash info storage, proving tx existence bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash), ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))), ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)), ZeroCopySink.WriteUint64(toChainId), ZeroCopySink.WriteVarBytes(toContract), ZeroCopySink.WriteVarBytes(method), ZeroCopySink.WriteVarBytes(txData) ); // Must save it in the storage to be included in the proof to be verified. require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\"); // Fire the cross chain event denoting there is a cross chain request from Ethereum network to other public chains through Poly chain network emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam); return true; } Only the contracts in the whitelist can call this method. When a cross-chain function is carried out interact, it creates cross-chain transactions invoked by service contracts the logic cont. This method constructs the rawParam, which contains transaction hash, msg.sender, target chain ID, business logic contract to be invoked on target chain, the target method to be invoked, and the serialized transaction data which has been already constructed in the business logic contract. Then put the hash of rawParam into storage, proving the existence of the transaction. Step4. Verifying & executing This step is meant to implement the methods of verifying the block header and Merkle proof. If passing the verification, the transaction could be executed on the target chain. Example: /* * @param proof Poly chain transaction Merkle proof * @param rawHeader The header containing crossStateRoot to verify the above tx Merkle proof * @param headerProof The header Merkle proof used to verify rawHeader * @param curRawHeader Any header in current epoch consensus of Poly chain * @param headerSig The converted signature variable for solidity derived from Poly chain consensus nodes' signature * used to verify the validity of curRawHeader * @return true or false */ function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){ ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader); // Load ehereum cross chain data contract IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress); // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[] address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes()); uint256 curEpochStartHeight = eccd.getCurEpochStartHeight(); uint n = polyChainBKs.length; if (header.height >= curEpochStartHeight) { // It's enough to verify rawHeader signature require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\"); } else { // We need to verify the signature of curHeader require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\"); // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader); bytes memory proveValue = ECCUtils.MerkleProve(headerProof, curHeader.blockRoot); require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\"); } // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof bytes memory toMerkleValueBs = ECCUtils.MerkleProve(proof, header.crossStatesRoot); // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs); require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\"); require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\"); // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network require(toMerkleValue.makeTxParam.toChainId == chainId, \"This Tx is not aiming at this network!\"); // Obtain the target contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract); // only invoke PreWhiteListed Contract and method For Now require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],\"Invalid to contract or method\"); //TODO: check this part to make sure we commit the next line when doing local net UT test require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\"); // Fire the cross chain event denoting the executation of cross chain tx is successful, // and this tx is coming from other public chains to current Ethereum network emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash); return true; } /* * @notice Dynamically invoke the target contract, trigger execution of cross-chain tx on Ethereum side * @param _toContract the Ethereum Cross Chain Manager contract will invoke the target contract * @param _method At which method will be invoked within the target contract * @param _args The parameter that will be passed into the target contract * @param _fromContractAddr From chain smart contract address * @param _fromChainId Indicate from which chain current cross-chain tx comes * @return true or false */ function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){ // Ensure the target contract gonna be invoked is indeed a contract rather than a normal account address require(Utils.isContract(_toContract), \"The passed in address is not a contract!\"); bytes memory returnData; bool success; // The returnData will be bytes32, the last byte must be 01; (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_args, _fromContractAddr, _fromChainId))); // Ensure the executation is successful require(success == true, \"EthCrossChain call business contract failed\"); // Ensure the returned value is true require(returnData.length != 0, \"No return value from business contract!\"); (bool res,) = ZeroCopySource.NextBool(returnData, 31); require(res == true, \"EthCrossChain call business contract return is not true\"); return true; } The relayer should invoke this method. In some cases, users could invoke this method by themselves if they get the valid block information from Poly. This method fetches and processes cross-chain transactions, finds the Merkle root of a transaction based on the block height (in the block header), and verifies the transaction's legitimacy using the transaction parameters. After verifying the Poly chain block header and proof, you still need to check if the parameters toContract and toMerkleValue.makeTxParam.method have been listed in whitelists. Then it will invoke the business logic contract deployed on the target chain. Invoking will be processed through the internal method _executeCrossChainTx(): This method is meant to invoke the target contract and trigger the execution of cross-chain tx on the target chain. Firstly, you need to ensure that the target contract is waiting to be invoked a contract rather than a standard account address. Then construct a target business logic contract method: you need to encodePacked the _method and the input data format \"(bytes,bytes,uint64)\". Then it would keccak256 the encoded string, using bytes4 to take the first four bytes of the call data for a function call specifies the function to be called. Parameter _method is from the toMerkleValue, which is parsed from proof. And the input parameters format is restricted as (bytes _args, bytes _fromContractAddr, uint64 _fromChainId). These two parts are encodePacked as a method call. After calling the method, you need to check the return value. Only if the return value is true will the whole cross-chain transaction be executed successfully. To guarantee the safety of the CCM contract, we keep whitelists of contract addresses and methods to prevent invalid calls. Meanwhile, we also set whiteLister to manage these whitelists of the CCM contract. Here is the template for adding a whitelist. We highly encourage developers to develop similar features of authority management in personal projects. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 15:08:29 "},"new_chain/relayer/relayer.html":{"url":"new_chain/relayer/relayer.html","title":"Develop for Relayer","keywords":"","body":"Develop for Relayer 1. Development Specifications This step shows how to develop a relayer for your chain or project. The relayer plays a role in delivering messages between different chains, which is part of the cross-chain ecosystem. There are two components required: Chain Listener and Chain Submitter. 1.1 Chain Listener Chain listener fetches data from the source chain and poly chain, including block header, cross-chain events emitted from CCM, and Merkle proofs used to verify the cross-chain message in the poly chain. And the interface listed is necessary. type IChainListener interface { // Initialize with config Init(*config.ListenerConfig, *poly.SDK) error // Blocks to confirm Defer() int // New block check interval ListenCheck() time.Duration // Chain Id ChainId() uint64 // Optional: Fetch block header and header hash, used to submit to poly chain for verifications Header(height uint64) (header []byte, hash []byte, err error) // Optional: Last header sync state in poly chain. LastHeaderSync(uint64, uint64) (uint64, error) // Scan cross chain transactions included in the block Scan(uint64) ([]*msg.Tx, error) // Compose cross chain message before submit to poly chain Compose(*msg.Tx) error // Current chain height LatestHeight() (uint64, error) } 1.2 Chain Submitter Chain Submitter delivers messages to the target chain, including validator changes of poly chain to CCD and cross-chain messages. Additionally, Chain Submitter will check whether the transaction has been verified in CCD. And the interface listed is necessary. type IChainSubmitter interface { // Initialize with config Init(*config.SubmitterConfig) error // Submit message/transaction to the chain Submit(msg.Message) error // Start the thread Start(context.Context, *sync.WaitGroup, bus.TxBus, bus.DelayedTxBus, msg.PolyComposer) error // Process the cross chain message from poly chain ProcessTx(*msg.Tx, msg.PolyComposer) error } 2. Develop Steps on Poly-Relayer Poly-Relayer is a relayer project maintained by Poly Network. If you choose to develop based on Poly-Relayer, please follow the listed steps. Step1. Prerequisites The Poly-Relayer project is based on the bridge-common library. So you need to: Add chain ID in the bridge-common project here. Add chain client SDK here for common usage. Add chain wallet here for common usage. Step2. Interface implementation Implement interface IChainListener and IChainSubmitter for the new chain. Step3. Registration Register ChainListener and ChainSubmitter in selectors located in the relayer.go file. 3. Preparation for Launch The configs are required when launching relayer: Make sure necessary configuration is specified in config.json, including CCM contract, CCD contract, and other details for the chain. You can see a sample here. [!Note|style:flat|label:Notice] If you develop the relayer for the chain integrated with Poly Network, you can directly fetch CCD and CCM contracts. If you develop the relayer for a new chain, please complete the contract yourself. Check Poly public nodes in here. Specify roles to enable in roles.json and see a sample here. Roles Quantity Demand Description HeaderSync One or multiple for each chain It submits chain headers to the poly chain. TxListen Only one for each chain It observes cross-chain transactions from the source chain and pushes them to the message queue. TxCommit One or multiple for each chain It consumes the message queue and submits the cross-chain transactions to poly. PolyListen Only One for poly chain It observes cross-chain transactions from the poly chain and pushes them to the message queue. PolyCommit One or multiple for poly chain It consumes the message queue and submits the cross-chain transaction to the target chain. Now you are ready for the relayer, and please see the chapter of Test and Launch for details to launch. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 15:00:52 "},"new_chain/launch_and_test/launch.html":{"url":"new_chain/launch_and_test/launch.html","title":"Test and Launch","keywords":"","body":"Test and Launch 1. Test the Project There are two steps to test the interaction between your chain and Poly chain. 1.1 Debugging on DevNet Here is DevNet provided for developers to debug and test your codes. The access steps are as follows: Propose a request to submit code developed for Poly chain to GitHub and wait for code review. Propose a request to submit code developed for the new chain to Github and wait for code review. Submit the Cross-chain contracts hash you have deployed and the RPC that can connect your chain, then wait for the Poly team to allocate chain ID and router number. Register to Poly Chain and sync genesis block header. The details are as follows: Register to Poly Chain Call entry function RegisterSideChain Call entry function ApproveRegisterSideChain Sync genesis block header Call entry function SyncSideChainGenesisHeader [!Note|style:flat|label:Notice] Registration is currently completed by the Poly team with the trusted account. Launch your relayer. If you choose to develop based on poly relayer, please propose a request to submit code to Github and execute the subcommands below: Generate a poly chain wallet, and contact Poly team via to add whitelist. Compile the branch you developed../build.sh devnet/testnet/mainnet Execute settxblock to set the initial scan height../relayer_main settxblock --height --chain Executesetheaderblock to set the header sync height (This command is optional. If it fails, header sync will start from the registered height)../relayer_main setheaderblock --height --chain Start the serve../server --config ./config.json --roles ./roles.json Executestatus to show how relayer works../relayer_main status [!Note|style:flat|label:Notice] Complete the corresponding actions if you develop a relayer independent from Poly relayer. Notes on debugging: Check your wallet balance regularly to avoid problems caused by insufficient balance. Create multiple wallet accounts, which can speed up the cross-chain transaction. Make sure the chain has been registered before launching relayer. Ensure the relayer can work correctly, and check whether the block header can be accurately and continuously synchronized in both the poly chain and your chain. Synchronization is the prerequisite of processing cross-chain information. Check whether the cross-chain transaction can be verified correctly. You are suggested to deploy a simple business logic contract logic to call the cross-chain function and test if the three parts (Poly chain, your contract, and relayer) work well together. [!Note|style:flat|label:Notice] Here you are recommended to interact with your chain on DevNet, which means when you call the cross-chain function, the \"toChainId\" (the input parameter of cross-chain function) is your chain ID registered in Poly Chain. 1.2 Test on TestNet Here is TestNet provided for developers to test the interaction between chains. The access to TestNet is almost the same as that of DevNet, Propose a request to submit code developed for the poly chain to Github and wait for code review. Propose a request to submit code developed for the new chain to Github and wait for code review. Submit the cross-chain contract hash, RPC, chain name to Poly. Register to Poly Chain and sync genesis block header on Poly TestNet. The detail is consistent with DevNet and is also completed by Poly Network. Deploy a business contract on the chain you want to interact with and provide the function called by the target chain to Poly Network. Launch your relayer, which is the same as what is on DevNet. Notes on the test: The transaction has been completed on the source chain but not completed on Poly: Is the block header synchronization normal？ Does the relayer catch the transaction? Is the input parameter \"toChainId\" (the input parameter of cross-chain function, i.e., the target chain ID) is correct? The transaction hasn't been completed on the target chain: Is the \"method\" (the function of your contract called by target chain) allowed to be called by CCM contract on target chain? Can \"txData\" (the input parameter of cross-chain function) be parsed correctly by \"method\" on the target chain？ 2. Launch on MainNet Now you can follow the processes to launch your project on MainNet： Notify Poly team via to merge the final code (including contracts and Poly code) into the MainNet, which should be taken about one week ahead of your launch schedule. Submit the cross-chain contract hash deployed on MainNet, MainNet RPC, chain name to Poly. Please verify your contract code. Register to Poly Chain and sync genesis block header on Poly MainNet. The detail is consistent with TestNet and DevNet, and is also completed by Poly Network. Launch your relayer. Congratulations! You have integrated your chain in Poly Network. If you want to deploy products, please refer to other guides we provide: Build New Bridges Customize Business Logic Contract Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:44:33 "},"new_product/integrate_bridge/readme.html":{"url":"new_product/integrate_bridge/readme.html","title":"Build New Bridges","keywords":"","body":"Build New Bridges Except for building a new chain, you may want to join Poly cross-chain ecosystem via just connecting with Poly Bridge or integrating the APIs provided by Poly Bridge into your own cross-chain bridge. Then, the listed information will be helpful for you. 1. Main Functions of Poly Bridge Monitor cross-chain eventDuring transaction, Poly Bridge will monitor the wrapper events emitted by the wrapper contract on the source chain, the lock event (on source chain) and unlock event (on target chain) emitted by CCM contracts. Link cross-chain eventsPoly Bridge links the events monitored from source chain, poly chain and target chain depending on the transaction key, and update the status of the cross-chain transaction simultaneously. Synchronize cross-chain feePoly Bridge will synchronize the transaction fee of target chain to facilitate users when they initiate a cross-chain transaction. Synchronize cross-chain token pricePoly Bridge also synchronizes the price of tokens both on source chain and target chain from the market, making users be informed about the exchange rate and accurately calculate transaction fee. [!Note|style:flat|label:Notice] For now, Poly Bridge is deployed by Poly team. 2. Integrating Poly Bridge APIs Even if you want to implement your own cross-chain bridge, you need to realize the four main functions mentioned above.And for your convenience, Poly Bridge also provides some API for you to integrate into your own cross-chain bridge. You can find them in here. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 10:13:25 "},"new_product/integrate_bridge/bridge.html":{"url":"new_product/integrate_bridge/bridge.html","title":"API","keywords":"","body":"API The following APIs are provided for developers who need to implement the bridge function. If you want to integrate into the Poly bridge, please get in touch with Poly team via for more support. Poly Bridge APIs: Get cross-chain fee. Get cross-chain transaction status. Get transaction history. Get basic token information. Get token mapping relationship between different chains. Get the expected cross-chain duration. Get cross chain fee This API returns a transaction fee charged on the source chain in a cross-chain transaction. And if SwapTokenHash is specified, the transferable amount will be returned. API Testnet: https://bridge.poly.network/testnet/v1/getfee Mainnet: https://bridge.poly.network/v1/getfee Parameter /* @SrcChainId: source chain id * @SwapTokenHash: the hash of the cross-chain token on the source chain * @Hash: The token hash used to charge fees * @DstChainId: target chain id */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/getfee' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"SrcChainId\": 2, \"SwapTokenHash\": \"0d9c8723b343a8368bebe0b5e89273ff8d712e3c\", \"Hash\": \"0000000000000000000000000000000000000000\", \"DstChainId\": 3 }' Example Response { \"SrcChainId\": 2, \"Hash\": \"0000000000000000000000000000000000000000\", \"DstChainId\": 3, \"UsdtAmount\": \"0.1874142096\", \"TokenAmount\": \"0.00006131\", \"TokenAmountWithPrecision\": \"6.1318011405463236515e+13\", \"SwapTokenHash\": \"0d9c8723b343a8368bebe0b5e89273ff8d712e3c\", \"Balance\": \"2.9553450781056623353e+41\", \"BalanceWithPrecision\": \"2.9553450781056623352e+47\" } Get the cross chain transaction status This API returns the details of the assigned hash, and you can view the cross-chain procedure through the TransactionState in the response. API Testnet: https://bridge.poly.network/testnet/v1//transactionofhash Mainnet: https://bridge.poly.network/v1/transactionofhash Parameter /* * @Hash: the cross chain transaction hash */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1//transactionofhash' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"Hash\": \"0b2c42b35e811b973c1d9258214cc68e63059271256bfb89239198cd1a7bda98\" }' Example Response { \"Hash\": \"4496cdb2905c148c06039a83d4130f04ddae498aa1065b06430ccd2766b08f78\", \"User\": \"547f1e7f552ec9701a8a4b4c30c6bbf3fff513cf\", \"SrcChainId\": 7, \"BlockHeight\": 12538043, \"Time\": 1644508161, \"DstChainId\": 6, \"FeeAmount\": \"2.59436134\", \"TransferAmount\": \"21926.387813549774936158\", \"DstUser\": \"bc7128144f31da5a1eff7c79e86d6c0b01af3de6\", \"ServerId\": 0, \"State\": 0, \"Token\": { \"Hash\": \"25d2e80cb6b86881fd7e07dd263fb79f4abe033c\", \"ChainId\": 7, \"Name\": \"MDX\", \"Property\": 1, \"TokenBasicName\": \"MDX\", \"Precision\": 18, \"AvailableAmount\": \"21578714598525328008311694\", \"TokenBasic\": { \"Name\": \"MDX\", \"Precision\": 18, \"Price\": \"0.28673118\", \"Ind\": 1, \"Time\": 1644508861, \"Property\": 1, \"Meta\": \"https://app.ont.io/poly/mdx.svg\" } }, \"FeeToken\": { \"Hash\": \"25d2e80cb6b86881fd7e07dd263fb79f4abe033c\", \"ChainId\": 7, \"Name\": \"MDX\", \"Property\": 1, \"TokenBasicName\": \"MDX\", \"Precision\": 18, \"AvailableAmount\": \"21578714598525328008311694\" }, \"TransactionState\": [ { \"Hash\": \"4496cdb2905c148c06039a83d4130f04ddae498aa1065b06430ccd2766b08f78\", \"ChainId\": 7, \"Blocks\": 21, \"NeedBlocks\": 21, \"Time\": 1644508161 }, { \"Hash\": \"e93416eac8f52b9e1d7523ebecceb901b6cddb08d6c0e851903e52094f92cb77\", \"ChainId\": 0, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644508259 }, { \"Hash\": \"8d9cfefed98e22015f6baab9ab5abb9b33e8ca2b70003a774f12a90a8bb65273\", \"ChainId\": 6, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644508270 } ] } Get transaction history This API returns the cross-chain history of the assigned address. API Testnet: https://bridge.poly.network/testnet/v1/transactionsofaddress Mainnet: https://bridge.poly.network/v1/transactionsofaddress Parameter /* @Addresses: wallet address * @PageNo: start page * @PageSize: size of displays per page */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/transactionsofaddress' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"Addresses\": [ \"93aea6537acd6c10ed76ea8eb367c2ae4cfa2282\" ], \"PageNo\": 0, \"PageSize\": 10 }' Example Response { \"PageSize\": 1, \"PageNo\": 0, \"TotalPage\": 1, \"TotalCount\": 1, \"Transactions\": [ { \"Hash\": \"0b2c42b35e811b973c1d9258214cc68e63059271256bfb89239198cd1a7bda98\", \"User\": \"aecb8dff86f198ad3a812a00035438e553b230bd\", \"SrcChainId\": 88, \"BlockHeight\": 1163947, \"Time\": 1644997356, \"DstChainId\": 7, \"FeeAmount\": \"0.00023409\", \"TransferAmount\": \"1.23\", \"DstUser\": \"93aea6537acd6c10ed76ea8eb367c2ae4cfa2282\", \"ServerId\": 0, \"State\": 0, \"Token\": { \"Hash\": \"d2a4cff31913016155e38e474a2c06d08be276cf\", \"ChainId\": 88, \"Name\": \"GAS\", \"Property\": 1, \"TokenBasicName\": \"GAS\", \"Precision\": 8, \"AvailableAmount\": \"39455668193977\", \"TokenBasic\": { \"Name\": \"GAS\", \"Precision\": 8, \"Price\": \"5.50686187\", \"Ind\": 1, \"Time\": 1645095305, \"Property\": 1, \"Meta\": \"\" } }, \"FeeToken\": { \"Hash\": \"d2a4cff31913016155e38e474a2c06d08be276cf\", \"ChainId\": 88, \"Name\": \"GAS\", \"Property\": 1, \"TokenBasicName\": \"GAS\", \"Precision\": 8, \"AvailableAmount\": \"39455668193977\" }, \"TransactionState\": [ { \"Hash\": \"0b2c42b35e811b973c1d9258214cc68e63059271256bfb89239198cd1a7bda98\", \"ChainId\": 88, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644997356 }, { \"Hash\": \"331287ddc15029faa160dcf3846a57471d21b7b817fabbcd87e3fe4b80d89130\", \"ChainId\": 0, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644997377 }, { \"Hash\": \"42e45d1bdddc9bd3b63979676fd99f928fa741ea28a806cf385c001ac36ba101\", \"ChainId\": 7, \"Blocks\": 1, \"NeedBlocks\": 1, \"Time\": 1644997384 } ] } ] } Get token basic information This API returns the basic information of the token, including price, precision, meta data and the token information mapped on each chain. API Testnet: https://bridge.poly.network/testnet/v1/tokenbasics Mainnet: https://bridge.poly.network/v1/tokenbasics Parameter none Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/tokenbasics' Example Response { \"TotalCount\": 2, \"TokenBasics\": [ { \"Name\": \"8PAY\", \"Precision\": 18, \"Price\": \"1\", \"Ind\": 1, \"Time\": 0, \"Property\": 1, \"Meta\": \"https://app.ont.io/poly/8pay.jpg\", \"Tokens\": [ { \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"ChainId\": 79, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"28254867780000000000\" }, { \"Hash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"ChainId\": 2, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"71745132220000000000\" } ] } ] } Get token mapping relationship between different chains This API returns mapping relations between source chain and target chain of assigned token. API Testnet: https://bridge.poly.network/testnet/v1/tokenmap Mainnet：https://bridge.poly.network/v1/tokenmap Parameter /* @ChainId: source chain id * @Hash: source token hash */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/tokenmap' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"ChainId\": 79, \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\" }' Example Response { \"TotalCount\": 1, \"TokenMaps\": [ { \"SrcTokenHash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"SrcToken\": { \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"ChainId\": 79, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"28254867780000000000\" }, \"DstTokenHash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"DstToken\": { \"Hash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"ChainId\": 2, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"71745132220000000000\" }, \"Property\": 1 } ] } Get the expected cross-chain duration This API returns the expected elapsed time for token to transfer from source chain to target chain. API Testnet: https://bridge.poly.network/testnet/v1/expecttime Mainnet：https://bridge.poly.network/v1/expecttime Parameter /* @SrcChainId: source chain id * @DstChainId: target token hash */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/expecttime' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"SrcChainId\": 79, \"DstChainId\": 2 }' Example Response { \"TotalCount\": 1, \"TokenMaps\": [ { \"SrcTokenHash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"SrcToken\": { \"Hash\": \"48abb7954b5bc46be41cc444e731f9d03aa33feb\", \"ChainId\": 79, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"28254867780000000000\" }, \"DstTokenHash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"DstToken\": { \"Hash\": \"aa00fbcface6ff4913cc8322b12f63e2ad45d448\", \"ChainId\": 2, \"Name\": \"8pay\", \"Property\": 1, \"TokenBasicName\": \"8PAY\", \"Precision\": 18, \"AvailableAmount\": \"71745132220000000000\" }, \"Property\": 1 } ] } Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 15:16:18 "},"new_product/integrate_assets/readme.html":{"url":"new_product/integrate_assets/readme.html","title":"Import New Assets","keywords":"","body":"Import New Assets This section purposes to help you import assets into Poly Network. Considering that Poly Network has already included most mainstream chains, check whether your project supports the existing chains. If not, please connect your chain first. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 10:13:25 "},"new_product/integrate_assets/token.html":{"url":"new_product/integrate_assets/token.html","title":"Import Token","keywords":"","body":"Importing Tokens As for importing tokens, here are four steps listed for you. Step1. Asset deployment Deploy mapping contracts of the corresponding asset on the target chain using the template. Ensure the total amount of contracts stays consistent with the amount on the source chain. Step2. Assets transfer Transfer the initialized assets to the target chain proxy contract. Step3. Information submission Download the asset template and fill in the information according to an example in the template. Submit the .xlsx file to poly. Contact Poly Network via Step4. Test Wait until the operators successfully add your contract address to the whitelist. Click here and follow the User Manual to test the token cross-chain transfer. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:48:12 "},"new_product/integrate_assets/nft.html":{"url":"new_product/integrate_assets/nft.html","title":"Import NFT","keywords":"","body":"Import NFT In most cases, you only need to deploy the NFT contract on the source chain, and Poly Network will deploy the NFT proxy contract on the target chain. The source NFT contract must support the EIP-721 standard. It should be noted here that the EIP-721 standard excludes the mint method. In our cross-chain process, Poly Network will determine whether this asset is in the target contract when the newly generated asset on the source chain is transferred. If not, a new NFT will be minted. Here are three steps listed for you to import NFT. Step1. Development and deployment Develop a contract following the NFT template provided by Poly Network. This contract implements a minting interface using the Poly Network standard: function mintWithURI(address to, uint256 tokenId, string memory uri) external This method will be called in the NFTLockProxy contract of Poly Network. [!Note|style:flat|label:Notice] If you want to deploy the NFT contract on the target chain by yourself, please implement the interface below and ensure that the method name, parameters, and order are strictly consistent. If your contract does not implement _safeMint, _setTokenURI, etc., you should implement first. If you have implemented these methods, you can directly copy the following code: function mintWithURI(address to, uint256 tokenId, string memory uri) external { require(!_exists(tokenId), \"token id already exist\"); _safeMint(to, tokenId); _setTokenURI(tokenId, uri); } Step2. Information submission Download the asset template and fill in the information according to an example in Excel. Submit the .xlsx file to poly. Contact Poly Network via Step3. Test Wait until the operators successfully add your contract address to the whitelist. Click here and follow the User Manual to test the NFT cross-chain transfer. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:47:23 "},"new_product/integrate_contracts/readme.html":{"url":"new_product/integrate_contracts/readme.html","title":"Customize Business Logic Contracts","keywords":"","body":"Customize Business Logic Contracts This section introduces you to the process of cross-chain interconnection and how to build your business logic contract and join into the vast cross-chain ecosystem. CCM contract remains two interfaces for direct interconnection with customized business logic contracts. So, you can write your business logic contracts both on the source and target chains. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 15:04:40 "},"new_product/integrate_contracts/Customizing Business Logic Contract.html":{"url":"new_product/integrate_contracts/Customizing Business Logic Contract.html","title":"Guidelines for Developing","keywords":"","body":"Guidelines for Developing Chains must and must only be deployed with one CCM contract to implement cross-chain features. And for normal running, all the business logic contracts have to interconnect with the CCM contract via the interfaces offered by the CCM contract. See the following for a detailed description or reference to the complete code of the CCM contract. [!Note|style:flat|label:Notice] To implement cross-chain features, you need to ensure that the cross-chain methods in your business logic contracts have authorized CCM of Poly. Step1. Mapping asset Except for verifying the existence of transactions through the CCM contract, the business logic contract needs to ensure the accuracy of the asset relationship in the transaction. Therefore, the business contract should maintain both the asset mapping and business logic contract mapping. Asset hash is mapped from the source chain to the target chain, and target chain ID is mapped to the business logic contract address on the target chain. Example: The asset mapping relationship stored in the business logic contract will help complete transaction data. Binding actions also prevent the wrong input from users, leading to the transfer of assets to the incorrect asset contract address. pragma solidity ^0.5.0; import \"./../../libs/ownership/Ownable.sol\"; contract LockProxy is Ownable { address public managerProxyContract; mapping(uint64 => bytes) public proxyHashMap; mapping(address => mapping(uint64 => bytes)) public assetHashMap; // toChainId: the target chain id // targetProxyHash: the address of business logic contract on target chain function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) { proxyHashMap[toChainId] = targetProxyHash; emit BindProxyEvent(toChainId, targetProxyHash); return true; } // fromAssetHash: asset hash on source chain // toAssetHash: asset hash on target chain function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) { assetHashMap[fromAssetHash][toChainId] = toAssetHash; emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash)); return true; } } Step2. Requesting transaction This interface creates cross-chain transactions invoked by business logic contracts when a cross-chain function is carried out in the logic contract. /* * @param toChainId The target chain id * @param toAddress The address in bytes format to receive the same amount of tokens in the target chain * @param toContract Target smart contract address in bytes in the target blockchain * @param txData Transaction data for target chain, include toAssetHash, toAddress, amount * @return true or false */ function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) This method constructs the rawParam, which contains transaction hash, msg.sender, target chain ID, business logic contract on target chain, the target method to be invoked, and the serialized transaction data has been already constructed in the business logic contract. Then put the hash of rawParam into storage to prove the cross-chain transaction. Example: /* * @param fromAssetHash The asset address in the current chain * @param toChainId The target chain id * @param toAddress The address in bytes format to receive the same amount of tokens in the target chain * @param amount The number of tokens to be crossed from Ethereum to the chain with chainId */ function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) { require(amount != 0, \"amount cannot be zero!\"); require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract failed!\"); bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId]; require(toAssetHash.length != 0, \"empty illegal toAssetHash\"); TxArgs memory txArgs = TxArgs({ toAssetHash: toAssetHash, toAddress: toAddress, amount: amount }); bytes memory txData = _serializeTxArgs(txArgs); IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract); address eccmAddr = eccmp.getEthCrossChainManager(); IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr); bytes memory toProxyHash = proxyHashMap[toChainId]; require(toProxyHash.length != 0, \"empty illegal toProxyHash\"); require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\"); emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount); return true; } This function is invoked by users. Users can request a cross-chain transaction through the dApps, which works in the source chain. Then the business logic contract will get the transaction information involving asset contract address on source chain, target chain ID, target address, and amount of token to be transferred. By calling this method, the business logic contract will lock a certain amount to asset contract; Then the transaction data will be packed, which invokes the CCM contract. The CCM contract transfers the parameters of transaction data to the target chain based on block generation on the source chain; The serialized transaction data, chain ID, business logic contract address** of target chain, and the method needing to be called on target chain will be sent through crossChain() in the CCM contract. Step3. Verifying and executing This method is invoked by the relayer, but in some cases, users could also invoke this method by themselves if they get the valid block information from Poly. /* * @param proof Poly chain transaction Merkle proof * @param rawHeader The header containing crossStateRoot to verify the above tx Merkle proof * @param headerProof The header Merkle proof used to verify rawHeader * @param curRawHeader Any header in current epoch consensus of Poly chain * @param headerSig The converted signature variable for solidity derived from Poly chain consensus nodes' signature * used to verify the validity of curRawHeader * @return true or false */ function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader, bytes memory headerSig) whenNotPaused public returns (bool) This method fetches and processes cross-chain transactions, finds the Merkle root of a transaction based on the block height (in the block header), and verifies the transaction's legitimacy using the transaction parameters. After verifying the Poly chain block header and proof, it will invoke the business logic contract deployed on the target chain. Invoking will be processed through the internal method _executeCrossChainTx(): This method is meant to invoke the target contract and trigger the execution of cross-chain tx on the target chain. Firstly, you need to ensure that the target contract is waiting to be invoked a contract rather than a standard account address. Then construct a method calling on target business logic contract: You need to encodePacked the _method and the format of input data \"(bytes,bytes,uint64)\"; Then it would keccak256 the encoded string, using bytes4 to take the first four bytes of the call data for a function call specifies the function to be called. Parameter _method is from the toMerkleValue, which is parsed from proof. And the input parameters format is restricted as (bytes _args, bytes _fromContractAddr, uint64 _fromChainId). These two parts are encodePacked as a method call. After calling the method, you need to check the return value. Only if the return value is true will the whole cross-chain transaction be executed successfully. Example: /* * @param argsBs The argument bytes received by the lock proxy contract on source chain, * need to be deserialized based on the way of serialization in the * lock proxy contract on source chain. * @param fromContractAddr The source chain contract address * @param fromChainId The source chain id */ function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) { TxArgs memory args = _deserializeTxArgs(argsBs); require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\"); require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\"); require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\"); address toAssetHash = Utils.bytesToAddress(args.toAssetHash); require(args.toAddress.length != 0, \"toAddress cannot be empty\"); address toAddress = Utils.bytesToAddress(args.toAddress); require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\"); emit UnlockEvent(toAssetHash, toAddress, args.amount); return true; } This function is invoked by the CCM contract. It deserializes the transaction data and invokes the asset contract to release the tokens to the target address. verifyHeaderAndExecuteTx() in CCM contract determines the legitimacy of cross-chain transaction information and resolves the parameters of transaction data from the Poly chain transaction Merkle proof and crossStateRoot contained in the block header. After verification through Poly, the packed transaction data could be executed on the target chain. Then call the function unlock() to deserialize the transaction data, transfer a certain amount of token to the target address on the target chain, and complete the cross-chain contract invocation. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 15:13:10 "},"new_product/integrate_contracts/launch.html":{"url":"new_product/integrate_contracts/launch.html","title":"Test and Launch","keywords":"","body":"Test and Launch 1. Test Your Contracts There are two steps for you to test your contract. [!Note|style:flat|label:Notice] The premise of contract testing is that both the original and target chains you want to test have been connected to the Poly Network. Otherwise, the test cannot be performed. Step 1. Preparation Deploy your contract in the source chain and target chain (For safety, you are recommended to complete the test in TestNet. If you have to do it on MainNet, please contact Poly team via ). Please submit the \"method\" (the input parameter of cross-chain function, i.e., the function of your contract called by target chain). The poly team will add this \"method\" to the whitelist of relayer to process transactions automatically. Otherwise, the transaction cannot process in the Poly chain. Step 2. Test on Poly Network After preparation, you can try to call the cross-chain function in your contract, and then you can query the steps of the cross-chain transaction here. Analyze contract issues based on the steps the transaction reached: The transaction has been completed on the source chain but not completed on Poly: If the transaction has been stuck in this step for over 5 minutes, consider whether the input parameter \"toChainId\" (the input parameter of the cross-chain function, i.e., the target chain ID) is correct. If the \"toChainId\" is correct, please contact Poly team via . [!Note|style:flat|label:Notice] The \"toChainId\" refers to the target chain ID registered on the poly, not the network ID. For details, see Chain ID. Please note that the IDs on the TestNet and the MainNet are different. The transaction hasn't been completed on the target chain: Call the API getmanualtxdata with Poly chain hash (the second transaction hash). API Testnet: https://bridge.poly.network/testnet/v1/getmanualtxdata Mainnet: https://bridge.poly.network/v1/getmanualtxdata Parameter /* @SrcChainId: source chain id * @SwapTokenHash: the hash of the cross-chain token on the source chain * @Hash: The token hash used to charge fees * @DstChainId: target chain id */ Example Request curl --location --request POST 'https://bridge.poly.network/testnet/v1/getmanualtxdata' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"polyhash\": \"\", }' Example Response { \"data\": \"\", \"dst_ccm\": \"0x\" } Get the response \"data\" as the input data to send a transaction to \"dst_ccm\" on the target chain. [!Note|style:flat|label:Notice] This step is to call the verifyHeaderAndExecuteTx function of CCM on the target chain. The calling process is encapsulated in \"data,\" so sending a transaction with \"data\" to CCM on the target chain is all you need to do. If you encounter an error submitting this transaction, there is something wrong with your contract on the target chain. Consider the following problems: Make sure the \"method\" (the function of your contract called by target chain) is allowed to be called by CCM contract on the target chain. Check that the txData (one of the input parameters of the cross-chain function) can be parsed correctly by the \"method\" on the target chain. The transaction has been completed on the target chain: Congratulations! You have completed the cross-chain transaction. [!Note|style:flat|label:Notice] During the test, you will have to send the target transactions manually. It may not be a good idea for projects. If you want to realize the automatic process, a relayer is needed. There is a relayer solution for you. 2. Launch on MainNet After all, tests are completed on the TestNet; you are ready to launch on the MainNet. The steps are as follows: Firstly, deploy your contract on MainNet; Secondly, submit the \"method\" and the source contract hash you have deployed; Thirdly, launch your relayer (See here for steps). When all is done, you can start your cross-chain journey. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 15:13:19 "},"Core_Smart_Contract/User_Manuals/Token_Transaction.html":{"url":"Core_Smart_Contract/User_Manuals/Token_Transaction.html","title":"Token Transaction","keywords":"","body":"Token Transaction This is the user manual for token transactions on personal computers. Here are five steps listed to complete the cross-chain transaction on Poly Bridge. We take the token transaction between Metis and BSC on Poly Bridge as an example for your better understanding. At the very beginning, make sure you have entered Token Asset of Poly Bridge. Step 1. Asset selection Firstly, you need to select the token you want to transfer. As shown in the figures, click Asset, then you can choose the token in the pop window. Step 2. Network selection After asset selection, click From Network, and select the source network containing the chosen token in the pop window. Select the target network in the same way. [!Note|style:flat|label:Notice] The optional network shown in this figure is the network types supported by the Metis token. Please choose it according to the actual situation. Here the figure indicates that Metis token will be sent from Metis to the target network BSC. Step 3. Wallet connection The next step is to connect the wallet. You can click Connect Wallet or the wallet icon to connect your wallet.The difference is that clicking Connect Wallet will enable you to select wallets both on the source and target network, as shown in the latter figure. [!Note|style:flat|label:Notice] Different networks support different wallets, and the current support status is shown in the table. Network Wallet ETH Metamask/Math BSC Metamask/Binance/Math HECO/OK/Polygon/Metis Metamask Neo Metis/Neoline Ontology Cyano [!Note|style:flat|label:Notice] If the warning \"Please switch network\" appears, you should switch the network of wallet to keep consistent with the source network. Step 4. Transaction submission Enter the amount you plan to swap, then click Next. A pop window will appear to show the details of the transaction. Please check it carefully. If you make sure the transaction information is correct， you can click Confirm to submit the transaction and confirm it again. [!Note|style:flat|label:Notice] If this is your first swap, an approval operation is required before transaction submission. Approve Infinity or not depends on your actual situation. Step 5. Transaction checking After the submission, you can view the transaction result in History. When the transaction details are displayed in the figure, the transaction has been completed. Congratulations! Till now, you've completed your token transaction, and you can continue your cross-chain journey! Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:57:56 "},"Core_Smart_Contract/User_Manuals/NFT_Transaction.html":{"url":"Core_Smart_Contract/User_Manuals/NFT_Transaction.html","title":"NFT Transaction","keywords":"","body":"NFT Transaction This is the user manual for NFT transactions on a personal computer. Here are five steps listed to complete the cross-chain transaction on Poly Bridge. We take the NFT transaction between Bytom and BSC on Poly Bridge as an example for your better understanding. At the very beginning, make sure you have entered NFT Asset of Poly Bridge and seen the page as below: You can start your transaction journey on this page now! Step 1. Wallet connection on source chain Firstly, you should connect your wallet according to your needs, e.g., Bytom on MetaMask, by following the three steps shown below: Step 2. Chain selection Then, select chain and network according to the wallet you have chosen. Make sure your wallet has switched to the same network as the chain you select now on this page. [!Note|style:flat|label:Notice] All existing NFT assets will be shown before your wallet is connected or switched to the appropriate chain, as shown in this figure. And a window will pop up to suggest you connect your wallet to this chain when you click any NFT assets on it, as shown here: Step 3. NFT selection Click the NFT project, and you'll see all the assets contained in your wallet. Now select a NFT asset, e.g., #0. Step 4. Wallet connection on target chain Next, click CONNECT WALLET and connect the wallet on the target chain, e.g., BNB, as shown below: Step 5. Transaction submission Now you should click APPROVE and confirm in your wallet to authorize Poly for this NFT. After authorization and confirmation, you can click NEXT to proceed. Confirm the core information, including the two chains and transaction fee, and click CONFIRM in the pop window. [!Note|style:flat|label:Notice] The Fee collected by Poly shown on this page is used to cover the transaction fee on the target chain. You can click on the transaction hash to check its status during the transaction. Wait for several minutes, and you can check your transaction in History. Congratulations! Till now, you've completed your NFT transaction, and you can continue your cross-chain journey! Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:58:50 "},"Core_Smart_Contract/User_Manuals/Transaction_Acceleration.html":{"url":"Core_Smart_Contract/User_Manuals/Transaction_Acceleration.html","title":"Transaction Acceleration","keywords":"","body":"Transaction Acceleration Poly Bridge releases the acceleration function to help users speed up transactions when dealing with congested networks. This manual will show you how to use this function with the example of token transfer between Arbitrum and Ethereum. At the very beginning, please check the status of your transaction. When you have submitted a cross-chain transaction completed in Poly, click SPEED UP to use the acceleration function. [!Note|style:flat|label:Notice] If your transaction is only completed in the source chain, this function does not work. Here are three steps listed for you to accelerate your transaction on Poly Bridge. Step 1. Transaction selection Firstly, you should find the transaction that you want to accelerate. Click History on Poly Bridge to view the previous transaction, as shown in the figure. Step 2. Status checking Then check the status of the transaction and click Pending. Step 3. Speed-up or fee payment Now you can click SPEED UP or PAY if you didn't pay a gas fee for this transaction shown in the figure. [!Note|style:flat|label:Notice] Please ensure that your wallet is connected to the target network. If not, you must switch network first and then back to the Speed Up page. Remember that the network settings in your wallet should be consistent with the target network in Poly Bridge. If you haven’t connected your wallet yet, the pop-up window will require you to connect your wallet. After that, exit the page and go back to the Speed Up page. If you encounter an error report as shown in the figure, please do not resubmit this transaction. Turn back to your wallet to check the balance. After successfully submitting an accelerated transaction, you'll see a page as below, and please wait for a while. If it still doesn't work, please contact Poly team via . Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:59:01 "},"Core_Smart_Contract/Contract/CCD.html":{"url":"Core_Smart_Contract/Contract/CCD.html","title":"CCD","keywords":"","body":" CCD| CCM | CCMP | LockProxy | NFTLockProxy Chain Index Ethereum BSC Heco Palette Curve OKEx Polygon Arbitrum xDAI Avalanche Fantom Optimistic Metis Goerli Rinkeby Kovan Pixie Boba N/A N/A Ethereum Node Contract MainNet 0xcf2afe102057ba5c16f899271045a0a37fcb10f2 TestNet 0xA38366d552672556CE82426Da5031E2Ae0598dcD DevNet 0x25BB8E9C0Cc03B30d09769735208a47d389Ff36c Back to top BSC Node Contract MainNet 0x11e2A718d46EBe97645b87F2363AFE1BF28c2672 TestNet 0xE815E5B52A659d78c91B747f7A3b358cc4F04794 DevNet N/A Back to top Heco Node Contract MainNet 0x11e2A718d46EBe97645b87F2363AFE1BF28c2672 TestNet 0x709D63f3d1a46B89cE4F6a61C8fb16aB29fD26F8 DevNet N/A Back to top Palette Node Contract MainNet 0x250e76987d838a75310c34bf422ea9f1AC4Cc906 TestNet 0x17d37a71986b7592dF8BAD1a9F0FB8Da9792d8D3 DevNet N/A Back to top Curve Node Contract MainNet 0xd57Dc9E14Be808b514D30fC5e46a07Ba1e5Cf473 TestNet N/A DevNet N/A Back to top OKEx Node Contract MainNet 0xdb3A0149f3155cC1B6890FE382d309dB4b322630 TestNet 0xd1Acc7bc3BDA9a63eEF89357a6f4c705ee874f44 DevNet N/A Back to top Polygon Node Contract MainNet 0x7cea671dabfba880af6723bddd6b9f4caa15c87b TestNet 0xd097cf11c0215563AaAE2d3bb49366C59FFFa144 DevNet N/A Back to top Arbitrum Node Contract MainNet 0x11e2A718d46EBe97645b87F2363AFE1BF28c2672 TestNet 0x71c2003f90bA0D2ce8a79DE9a70E7dD41BBfB983 DevNet N/A Back to top xDAI Node Contract MainNet 0x4D6934E2bb813f48DC0A7bf7Ead0365D9c894163 TestNet 0xAefD220aE393144dcb5EFD6Ab55ABDf6a3d0444d DevNet N/A Back to top Avalanche Node Contract MainNet 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 TestNet 0x4d8BC48087b994AA419d4679069584a7C92586A8 DevNet N/A Back to top Fantom Node Contract MainNet 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 TestNet 0x4Bf7b284De2999628CBBEf6fE9F74f8B8E5eBF16 DevNet N/A Back to top Optimistic Node Contract MainNet 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 TestNet 0xbA6F835ECAE18f5Fc5eBc074e5A0B94422a13126 DevNet N/A Back to top Metis Node Contract MainNet 0x6c2A37Cf23E21EF3cFC45FdE2C0E1d3a9e7365f9 TestNet 0x30e6ec356ceF1cfe3c7e14392EA08448382327bD DevNet N/A Back to top Goerli Node Contract MainNet N/A TestNet 0x10BCC4B6C2555fF48540571ebe5aBa6D32915250 DevNet N/A Back to top Rinkeby Node Contract MainNet N/A TestNet 0xbA6F835ECAE18f5Fc5eBc074e5A0B94422a13126 DevNet N/A Back to top Kovan Node Contract MainNet N/A TestNet 0x7D87b4C81B9efE1783E0524a6f475F9C526641C2 DevNet N/A Back to top Pixie Node Contract MainNet N/A TestNet 0xF9Dd424e64E9264632a564FBDcC87Ba8eA40B5Ba DevNet N/A Back to top Boba Node Contract MainNet N/A TestNet 0x55a59c57a133d1c999b3Eaf5B16ad5c1F2e365c8 DevNet N/A Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-22 00:47:47 "},"Core_Smart_Contract/Contract/CCM.html":{"url":"Core_Smart_Contract/Contract/CCM.html","title":"CCM","keywords":"","body":" CCD| CCM | CCMP | LockProxy | NFTLockProxy Chain Index Ethereum Neo Legacy BSC Heco Palette Curve OKEx Neo N3 Polygon Zilliqa Arbitrum xDAI Avalanche Fantom Optimistic Metis Goerli Rinkeby Kovan Pixie Boba N/A N/A N/A N/A Ethereum Node Contract MainNet 0x14413419452Aaf089762A0c5e95eD2A13bBC488C TestNet 0xf989E80AAd477cB6059f366C0170a498909C4a55 DevNet N/A Back to top Neo Legacy Node Contract MainNet B: 0x82a3401fb9a60db42c6fa2ea2b6d62e872d6257f L: 7f25d672e8626d2beaa26f2cb40da6b91f40a382 TestNet B: 07946635d87e4120164835391e33a114135b69e1 L: 0xe1695b1314a1331e3935481620417ed835669407 DevNet B: 0x3135a1a4668688a3e15b004af3a718f2d67141ca L: ca4171d6f218a7f34a005be1a3888666a4a13531 Back to top BSC Node Contract MainNet 0x1c9Ca8aBb5da65d94DaD2E8Fb3f45535480d5909 TestNet 0x906bC93FF690d6D3D2C4E7A7dfA4dEbdEF2cD7CA DevNet N/A Back to top Heco Node Contract MainNet 0x7109c5F898C5667941B3D2A6451b4bFBeD2bdBbF TestNet 0x40039148ce624B560e5F5c095DdA90fc13442Cf8 DevNet N/A Back to top Palette Node Contract MainNet 0x1b02EEE12A7bF02922113a70d3D343De4b43f776 TestNet 0xB64EE4b7cf935C51233b6ED9b0732D3Bd26E3442 DevNet N/A Back to top Curve Node Contract MainNet 0x89D15F45597816C90cbafd32D0Bb8Fc99bE0B76f TestNet N/A DevNet N/A Back to top OKEx Node Contract MainNet 0x6CE66Cf89A17B5C22e757cca01beAD901fC8C7f2 TestNet 0x296f7f9f0e65152965e9BE12b349c14c7cE8eE85 DevNet N/A Back to top Neo N3 Node Contract MainNet B: 0x5ba6c543c5a86a85e9ab3f028a4ad849b924fab9 L: b9fa24b949d84a8a023fabe9856aa8c543c5a65b TestNet B: 2a774fa0404f020254f6db20616cf13adc448d61 L: 0x618d44dc3af16c6120dbf65402024f40a04f772a DevNet B: 0x7c842f3900ceba5bcdeeeec05c9b41ba63ad6cd2 L: d26cad63ba419b5cc0eeeecd5bbace00392f847c Back to top Polygon Node Contract MainNet 0xB16FED79a6Cb9270956f045F2E7989AFfb75d459 TestNet 0xe6d97637EFb55d8c81154E29aC343Bc447F80c19 DevNet N/A Back to top Zilliqa Node Contract MainNet 0xac9f601679a285c3ff0d95239a1dc7a7983df32d TestNet 0x720a3fb587b670de99d94925b6f99c9a63d462c1 DevNet N/A Back to top Arbitrum Node Contract MainNet 0x7ceA671DABFBa880aF6723bDdd6B9f4caA15C87B TestNet 0x3A77dB10eAa7436e608a99643Ab2bEB2E901C72C DevNet N/A Back to top xDAI Node Contract MainNet 0x2f7ac9436ba4B548f9582af91CA1Ef02cd2F1f03 TestNet 0xF87527a74215777391fE4AfD082FeeED3E5A0ca5 DevNet N/A Back to top Avalanche Node Contract MainNet 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac TestNet 0xf37D8C2d072b74d6532541B70319ef08f9F6a4a8 DevNet N/A Back to top Fantom Node Contract MainNet 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac TestNet 0x1C84D74084c3C3301BE4777A568D78211189c871 DevNet N/A Back to top Optimistic Node Contract MainNet 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac TestNet 0xC8042579D6b60E0e35161F228827E3Fa0F51d5B6 DevNet N/A Back to top Metis Node Contract MainNet 0x2aA63cd0b28FB4C31fA8e4E95Ec11815Be07b9Ac TestNet 0xd6fc5374649cea121395a4860FdB33F21783c4Af DevNet N/A Back to top Goerli Node Contract MainNet N/A TestNet 0xbA6F835ECAE18f5Fc5eBc074e5A0B94422a13126 DevNet N/A Back to top Rinkeby Node Contract MainNet N/A TestNet 0xC8042579D6b60E0e35161F228827E3Fa0F51d5B6 DevNet N/A Back to top Kovan Node Contract MainNet N/A TestNet 0x509fB7A017e33f18101dDC0d28Ac06aEaf6Edb4B DevNet N/A Back to top Pixie Node Contract MainNet N/A TestNet 0x2E830E0cf3dc8643B497F88C07c8A72EFE24B11f DevNet 0x6fd13dd4181dDb0f7463e19caC659FD3e9FB8a82 Back to top Boba Node Contract MainNet N/A TestNet 0xa65bD4431C38A4dD9c92ebE60dE3cb8C252c04E5 DevNet N/A Back to top Note B means big-endian, we can search the contract transaction history in corresponding explorer. L means little-endian, we usually use it as the asset hash input when we do binding asset hash operation. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-22 00:47:47 "},"Core_Smart_Contract/Contract/CCMP.html":{"url":"Core_Smart_Contract/Contract/CCMP.html","title":"CCMP","keywords":"","body":" CCD| CCM | CCMP | LockProxy | NFTLockProxy Chain Index Ethereum BSC Heco Palette Curve OKEx Polygon Zilliqa Arbitrum xDAI Avalanche Fantom Optimistic Metis Goerli Rinkeby Kovan Pixie Boba N/A Ethereum Node Contract MainNet 0x5a51e2ebf8d136926b9ca7b59b60464e7c44d2eb TestNet 0xb600c8a2e8852832B75DB9Da1A3A1c173eAb28d8 DevNet 0x7087E66D6874899A331b926C261fa5059328d95F Back to top BSC Node Contract MainNet 0xABD7f7B89c5fD5D0AEf06165f8173b1b83d7D5c9 TestNet 0x441C035446c947a97bD36b425B67907244576990 DevNet N/A Back to top Heco Node Contract MainNet 0xABD7f7B89c5fD5D0AEf06165f8173b1b83d7D5c9 TestNet 0xc5757b5d22984E534004cC7Fb1D59eD14EC510a5 DevNet N/A Back to top Palette Node Contract MainNet 0x7622058504412D5183352A7d350653DfFe58b1DC TestNet 0x309064768EBD4EeF8ce073888e2f1C7e1CCCa191 DevNet N/A Back to top Curve Node Contract MainNet 0x25293B33DE6c7097A27b6c12888a15e0AbFf3A00 TestNet N/A DevNet N/A Back to top OKEx Node Contract MainNet 0x4739fe955BE4704BcB7d6a699823F5B29217Baf6 TestNet 0x38917884b397447227fb45cbA0342F1bFf7A3470 DevNet N/A Back to top Polygon Node Contract MainNet 0x5366ea2b5b729ff3cef404c2408c8c60cc061b71 TestNet 0x15D3f62822a446b8C5fDBBef157f0b82b05c29Ab DevNet N/A Back to top Zilliqa Node Contract MainNet 0xfeafd3bb477c2d29ed078256698c7d9c37abcf20 TestNet 0x6b95e35a3355df6d841127349f243ef4f017eaf2 DevNet N/A Back to top Arbitrum Node Contract MainNet 0xABD7f7B89c5fD5D0AEf06165f8173b1b83d7D5c9 TestNet 0xeE96Aa05b320a570C489aBd5EEc546AE4Fb58Eb7 DevNet N/A Back to top xDAI Node Contract MainNet 0x28FF66a1B95d7CAcf8eDED2e658f768F44841212 TestNet 0x3E5ceC313CECaa37319e0F2C949656441103C429 DevNet N/A Back to top Avalanche Node Contract MainNet 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 TestNet 0xcdd05Ebaa1FA06a5cE9eB67663aE9Ec78B37bd5B DevNet N/A Back to top Fantom Node Contract MainNet 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 TestNet 0x74D67A4EFbA6Dbbb14DC574b6Db4F11f6b1C5af8 DevNet N/A Back to top Optimistic Node Contract MainNet 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 TestNet 0x0ca3f95c8f66C7B178414CCFd7a508d349b9f794 DevNet N/A Back to top Metis Node Contract MainNet 0xE3D0FB6E3cB5DA61EB18b06D035052441009d1E6 TestNet 0xD5a240f7F755bCa2aE992E807b06d24eB6DF7C12 DevNet N/A Back to top Goerli Node Contract MainNet N/A TestNet 0xC8042579D6b60E0e35161F228827E3Fa0F51d5B6 DevNet N/A Back to top Rinkeby Node Contract MainNet N/A TestNet 0x0ca3f95c8f66C7B178414CCFd7a508d349b9f794 DevNet N/A Back to top Kovan Node Contract MainNet N/A TestNet 0x8a85143cA6ec1e181C3A5Ae4042ca999bFbF571B DevNet N/A Back to top Pixie Node Contract MainNet N/A TestNet 0x8F967507Ae66ad78c12478E10cA07c9104eb24A7 DevNet 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 Back to top Boba Node Contract MainNet N/A TestNet 0x720aF2de5eA84b78AAC7BDFA812B47e41516D59c DevNet N/A Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-22 00:47:47 "},"Core_Smart_Contract/Contract/LockProxy.html":{"url":"Core_Smart_Contract/Contract/LockProxy.html","title":"LockProxy","keywords":"","body":" CCD| CCM | CCMP | LockProxy | NFTLockProxy Chain Index Ethereum Ontology Neo Legacy BSC Heco OKEx Neo N3 Polygon Zilliqa Arbitrum xDAI Avalanche Fantom Optimistic Metis Cosmos Goerli Rinkeby Kovan Pixie Cosmos-Gaia N/A N/A N/A N/A Ethereum Node Contract MainNet 0x250e76987d838a75310c34bf422ea9f1AC4Cc906 TestNet 0xD8aE73e06552E270340b63A8bcAbf9277a1aac99 DevNet 0x46DE64740cf839374afB264970f8D437732649cA Back to top Ontology Node Contract MainNet B: 86b4ab5d99037113867247a1e68f70e348c07597 L: 9775c048e3708fe6a1477286137103995dabb486 TestNet B: 33c439c502cb4b6ac5a1e8057a65fe1fa7c300e2 L: e200c3a71ffe657a05e8a1c56a4bcb02c539c433 DevNet B: ebad45b887c6bf7cc4c1df8f72da156bc91b04b7 L: b7041bc96b15da728fdfc1c47cbfc687b845adeb Back to top Neo Legacy Node Contract MainNet B: 0xe7fb2e1d937e71dbbb512e6375746181127282e7 L: e782721281617475632e51bbdb717e931d2efbe7 TestNet N/A DevNet B: 0x3fef7ac6598ad83f5e4d4338e65530eba2173294 L: 943217a2eb3055e638434d5e3fd88a59c67aef3f Back to top BSC Node Contract MainNet 0x2f7ac9436ba4B548f9582af91CA1Ef02cd2F1f03 TestNet 0x097Ae585BfEf78DDC8E266ABCb840dAF7265130c DevNet N/A Back to top Heco Node Contract MainNet 0x020c15e7d08A8Ec7D35bCf3AC3CCbF0BBf2704e6 TestNet 0x4a76E52600C6285029c8f7c52183cf86282cA5b8 DevNet N/A Back to top OKEx Node Contract MainNet 0x9a3658864Aa2Ccc63FA61eAAD5e4f65fA490cA7D TestNet 0x74cE7D56cd1b5AEe9A3345A490b5Ed768134C7D4 DevNet N/A Back to top Neo N3 Node Contract MainNet N/A TestNet N/A DevNet B: 0x5376f41082a84fb000c944b6d44ba85b14e20fe5 L: e50fe2145ba84bd4b644c900b04fa88210f47653 Back to top Polygon Node Contract MainNet 0x28ff66a1b95d7cacf8eded2e658f768f44841212 TestNet 0x4e5eF0CA5A94b169Fb010fb40DBFD57c4830f446 DevNet N/A Back to top Zilliqa Node Contract MainNet 0xd73c6b871b4d0e130d64581993b745fc938a5be7 TestNet 0xa5a43eecd29534edf80792a9889f52c77455245d DevNet N/A Back to top Arbitrum Node Contract MainNet 0x2f7ac9436ba4B548f9582af91CA1Ef02cd2F1f03 TestNet 0x97f72bA888A26A0F98C67cf15d781dDBFE64B990 DevNet N/A Back to top xDAI Node Contract MainNet 0x77F3A156e8E597C64d4a12d62f20a0d2ff839dD5 TestNet 0x52B3048eeF2E53bAF430B0bA4752999F244d1709 DevNet N/A Back to top Avalanche Node Contract MainNet 0xd3b90E2603D265Bf46dBC788059AC12D52B6AC57 TestNet 0x80a53FD352597AbA3dD52c722119865a8ed82632 DevNet N/A Back to top Fantom Node Contract MainNet 0xd3b90E2603D265Bf46dBC788059AC12D52B6AC57 TestNet 0x4a76E52600C6285029c8f7c52183cf86282cA5b8 DevNet N/A Back to top Optimistic Node Contract MainNet 0xd3b90E2603D265Bf46dBC788059AC12D52B6AC57 TestNet 0x8a85143cA6ec1e181C3A5Ae4042ca999bFbF571B DevNet N/A Back to top Metis Node Contract MainNet 0xeFB5a01Ed9f3E94B646233FB68537C5Cb45e301D TestNet 0x0AF53d318De279C8e67FcC6914acF387CFaA8B7E DevNet N/A Back to top Cosmos Node Contract MainNet N/A TestNet f71b55ef55cedc91fd007f7a9ba386ec978f3aa8 DevNet N/A Back to top Goerli Node Contract MainNet N/A TestNet 0x509fB7A017e33f18101dDC0d28Ac06aEaf6Edb4B DevNet N/A Back to top Rinkeby Node Contract MainNet N/A TestNet 0x8a85143cA6ec1e181C3A5Ae4042ca999bFbF571B DevNet N/A Back to top Kovan Node Contract MainNet N/A TestNet 0x95a10b809c9Cfd51A46652C785ac73d7269834b9 DevNet N/A Back to top Pixie Node Contract MainNet N/A TestNet 0x46Fc99509c4Aab0c958B8b2175edAa9C4963Ac09 DevNet 0xa85c9FC8F2c9060d674E0CA97F703a0A30619305 Back to top Cosmos-Gaia Node Contract MainNet N/A TestNet N/A DevNet f71b55ef55cedc91fd007f7a9ba386ec978f3aa8 Back to top Note B means big-endian, we can search the contract transaction history in corresponding explorer. L means little-endian, we usually use it as the asset hash input when we do binding asset hash operation. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-22 00:47:47 "},"Core_Smart_Contract/Contract/NFTLockProxy.html":{"url":"Core_Smart_Contract/Contract/NFTLockProxy.html","title":"NFTLockProxy","keywords":"","body":" CCD| CCM | CCMP | LockProxy | NFTLockProxy Chain Index Ethereum BSC Heco Palette Neo N3 Polygon Rinkeby Pixie N/A N/A Ethereum Node Contract MainNet 0x2cdfc90250EF967036838DA601099656e74bCfc5 TestNet 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 DevNet 0x25BB8E9C0Cc03B30d09769735208a47d389Ff36c Back to top BSC Node Contract MainNet 0x2cdfc90250EF967036838DA601099656e74bCfc5 TestNet 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 DevNet N/A Back to top Heco Node Contract MainNet 0x2cdfc90250EF967036838DA601099656e74bCfc5 TestNet 0x25BB8E9C0Cc03B30d09769735208a47d389Ff36c DevNet N/A Back to top Palette Node Contract MainNet 0xdCA22CbA4a2d3dA3883b479f824F2147efed1718 TestNet 0x6e5fB68D6B705A567d75135169cF69574225eBe6 DevNet N/A Back to top Neo N3 Node Contract MainNet N/A TestNet B: 1a9e25a2484e92fbca10379984db16221003cd7a L: 0x7acd03102216db84993710cafb924e48a2259e1a DevNet N/A Back to top Polygon Node Contract MainNet 0x359596463F4F4e5969330D74504A614c22885D62 TestNet 0x761fb099d021cf55ffe65f9bedd3e2bab52abccc DevNet N/A Back to top Rinkeby Node Contract MainNet N/A TestNet 0x9bEF1AE7304D3d2F344ea00e796ADa18cE1beb03 DevNet N/A Back to top Pixie Node Contract MainNet N/A TestNet 0xD54a267B2c983d883D39248Dd7002dc7405559E0 DevNet 0x6Bc728a0ce7e189CBfb8AD932fb57928106D2674 Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-22 00:47:47 "},"Core_Smart_Contract/Nodes/Nodes.html":{"url":"Core_Smart_Contract/Nodes/Nodes.html","title":"Nodes","keywords":"","body":" Decentralized Application MainNet Nodes | Decentralized Application TestNet Nodes Decentralized Application MainNet Nodes Chain IP Rpc Port Poly http://seed1.poly.network 20336 Neo Legacy http://seed9.ngd.network 11332 Neo N3 http://seed5.neo.org 10332 Back to top Decentralized Application TestNet Nodes Chain IP Rpc Port Poly http://beta1.poly.network 20336 Neo http://seed9.ngd.network 20332 Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-02-28 16:58:25 "},"Core_Smart_Contract/Chain_ID/Chain_ID.html":{"url":"Core_Smart_Contract/Chain_ID/Chain_ID.html","title":"Chain ID","keywords":"","body":" MainNet|TestNet|DevNet MainNet Chain ID Type Router Number Chain ID Bitcoin 1 1 Ethereum 2 2 Ontology 3 3 Neo Legacy 4 4 Switcheo 5 5 BSC 6 6 Heco 7 7 Palette 8 8 Zilliqa 17 18 Curve 10 10 OKExChain 12 12 Neo N3 14 14 Heimdall 15 15 Polygon 16 17 Arbitrum 0 19 xDAI 0 20 Avalanche 0 21 Fantom 0 22 Optimistic 0 23 Metis 0 24 Back to top TestNet Chain ID Type Router Number Chain ID Bitcoin 1 1 Ethereum 2 2 Ontology 3 3 NEO(N2) 4 5 Switcheo 5 - BSC 6 79 HECO 7 7 Palette 8 107 Zilliqa 111 111 OK 12 200 Curve 10 82 Heimdall 15 201 Polygon 16 202 NEO(N3) 88 88 Arbitrum 0 205 xDAI 0 206 Optimistic 0 207 Fantom 0 208 Avalanche 0 209 Metis 0 300 Goerli 0 502 Rinkeby 0 402 Kovan 0 302 Pixie 0 316 Boba 0 400 Back to top DevNet Chain ID Type Router Number Chain ID Bitcoin 1 1 Ethereum 2 2 Ontology 3 3 NEO Legacy 217 217 NEO N3 220 220 Cosmos-gaia 5 8 Switcheo 5 182 Pixie 19 321 Back to top Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-22 00:47:47 "},"GLOSSARY.html":{"url":"GLOSSARY.html","title":"Glossary","keywords":"","body":"Relayer A cross-chain information porter performs some of the most critical operations within the cross-chain. It acts as the medium of interaction between the side chain and the outside world. Each chain in the cross-chain ecosystem has a relayer associated with it. Relayer monitors its corresponding chain network for cross-chain transactions and forwards the respective block headers to the poly chain if detected, gaining available incentives in the process. At the same time, it also monitors cross-chain transactions taking place on the poly chain and transfers them to the respective side chain. Source Chain A public chain corresponds to the target chain where a particular asset firstly appears. Target Chain A public chain corresponds to the source chain on which we want to cross an asset and issue a new token. For the Ether asset, Ethereum is the source chain. When we want to issue a new OEP4 token in the Ontology network represents the Ether, the Ontology chain will be the target chain for the Ether asset. And vice versa, for the ONT token, the Ontology chain is the source chain. When we want to issue a new ERC20 token in the Ethereum chain, Ethereum would be the target chain for the Ont network. Poly Chain The relay chain in the cross-chain ecosystem. One of the crucial components of the cross-chain ecosystem. Each type of node is deployed and maintained by other individuals or organizations and has its unique governance and trust mechanism. The poly chain is responsible for connecting them, standardizing cross-chain data flow and interfaces, verifying the legitimacy of cross-chain data, etc. Canonical Block A block is included in the primary blockchain and is directly or indirectly referenced by future blocks. Blocks that are not canonical may have been valid but were discarded in favor of the canonical block. Cross Chain Council A Council formed by poly consensus nodes. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 10:13:25 "},"FAQ/template.html":{"url":"FAQ/template.html","title":"FAQ","keywords":"","body":"FAQ Though not exhaustive, these FAQs will help you get started and troubleshoot some of the most common user problems when using Poly Bridge. Stay Tuned with Us: Official site：https://www.poly.network/ Poly Bridge: https://bridge.poly.network Twitter: https://twitter.com/PolyNetwork2 Medium: https://medium.com/@polynetwork Telegram: https://t.me/polynetworkgroup Discord: https://discord.gg/xXxJa3sm Github: https://github.com/polynetwork User Guides and Tutorials: https://medium.com/poly-network/tagged/tutorial About Poly Network Ecosystem Q1: What is Poly Network? A: Poly Network is the world’s leading cross-chain interoperability protocol for heterogeneous chains, enhancing connections between ledgers by providing interoperability in Web 3.0. Its uniquely designed cross-chain bridge technology executes cross-chain transactions by deploying smart contracts on the source chain and enabling communication between heterogeneous chains, including the more popular public chains, right at the protocol layer. Poly Network has integrated over 18 blockchains, including Ethereum, BNB Chain, Polygon, Avalanche, Fantom, Arbitrum, Optimism,Metis, Boba, OEC, HECO, Neo, Ontology, Zilliqa,Gnosis Chain and etc. Q2: Is Poly Network related to Polygon, Polymath, or Poly chain Capital? A: No, Poly Network is not related to them. It’s just a coincidence that we all have \"POLY\" in our names. However, Poly Bridge supports transactions from and to the Polygon chain. About Poly Bridge When you first meet Poly Bridge, you may concern: Q1: What is Poly Bridge? What functions does it provide? Where is the website? A: Poly Bridge is a bridge through which you can transfer your asset (including tokens and NFTs) between different chains easily and quickly. Q2: What’s the relationship between Poly Network and Poly Bridge? A: Poly Network incorporated many dApps, including Poly Bridge that was created by Poly Network. If you are a developer, you may concern: Q1: How to integrate token onto Poly Bridge? A: Here is a manual instructing developers to integrate token onto Poly Bridge. Q2: Where can I find the contract? A: Here is an appendix that includes basic contracts and some business contracts deployed and used by Poly Network, please go to check it. If you are a user, you may concern: Q1: Does Poly Network issue any token? A: Poly Network hasn't issued any token yet. Q2: How to transfer my assets between two chains through Poly Bridge? A: Please refer to the manual. Q3: How much fee does Poly Bridge charge per transaction? A: In order to cover the gas fee charged by your target chain, Poly Bridge will collect fees accordingly when you cross-chain your assets. No extra fee is charged. Q4: Is the bridge rate 1:1? A: Normally yes, except for deflationary tokens. Q5: How long does it take per transaction? A: Average estimated time of arrival is 1–10 min. Irresistible factors such as network congestion might delay the transaction. If your transaction hasn’t been completed for a long time, please refer to Q6. Q6：I have waited a long time and still haven’t received my asset. What can I do? A: Please check which step your transaction has reached. Solutions vary from different steps： The transaction hasn't been completed on the source chain：For safety reasons, Poly Bridge will not confirm your transaction immediately until subsequent blocks have been confirmed (the number of subsequent blocks is different for different chains), please wait for block confirmation. The transaction has been completed on the source chain, but not completed on Poly: if the transaction has been stuck in this step for over 5 min, please do not hesitate to contact the Poly Network Team. The transaction hasn't been completed on the target chain: it’s perhaps down to the transaction congestion of the target chain, please wait for a while or refer to the accelerated transaction tutorial. If the accelerated tutorial doesn't work, please contact Poly Network team. Q7: Where can I find my previous transaction or check the status of my transaction? A: You can check your previous transaction in \"History\". And then click \"Status\" to check the current progress. Q8: The transaction is confirmed in my history but why aren’t the tokens showing in my metamask? A: You may have to manually add that specific token to your metamask. This can be achieved by selecting the \"import tokens\" option in your metamask wallet and then copy-paste the token contract address for the asset you wish to add. If properly executed, your tokens will appear in your wallet immediately. Q9: When an error is shown on my wallet page, what shall I do? A: Firstly, make sure you have approved enough amount for Poly Bridge contract to use the token; Secondly, make sure you have sufficient native tokens to cover the gas fee charged both by source chain and target chain and the amount you want to transfer. If you transfer native tokens: $amount in your wallet ≥ transfer amount + src chain gas fee + target chain gas fee. If you transfer non-native tokens: $native token amount in your wallet ≥ src chain gas fee + target chain gas fee. For example, if you want to transfer `METIS` from Andromeda to BSC, you have to reserve tokens both for source chain gas fee and for target chain gas fee. The rest are the amount of tokens you can transfer. For your better use, Poly Bridge set as follows: If $native token amount in your wallet If $native token amount in your wallet > transfer token amount + src chain gas fee + target chain gas fee, the max amount of transferable token = $native token amount in your wallet -target chain gas fee -estimated src chain gas fee. To guarantee the sufficient transaction fee on src chain, the estimated src chain gas fee could be slightly higher than the actual fee, so that some native tokens will remain in your account after transaction (i.e., native token won’t be totally transferred); Thirdly, if you encounter other types of error, please contact Poly Network team. Q10: When I click MAX, why is the amount of transferable token less than my overall balance? A: Here are three conditions: Poly bridge will reserve transaction fee of both src chain and target chain for users (Tips: the fee will be reserved only when the transferred token is native token). So, the transferable token amount doesn't equal to your account balance. Some tokens may have their own characteristics that limit the amount of transfer, so you may not be able to transfer all your assets in one time (but you can break it into several times). When the liquidity of target chain is lower than your account balance, you cannot transfer all your assets in one time. Please contact Poly Network team under this condition. Q11: Why is the liquidity of the target chain shown sufficient in \"Max available amount\" before sending a transaction and then after the transaction on the source chain is completed, the transaction on the target chain fails because of insufficient liquidity? A: The liquidity shown in \"Max available amount\" refers to liquidity for all users, not your share of the liquidity. If there are several users initiating large transactions at the same time, the liquidity might be insufficient for all transactions. It happens mostly when the amount you transfer is close to the max available amount. Under this occasion, Poly Network will contact the relevant project to add liquidity as soon as possible. Q12: Can I use Poly Bridge via mobile devices? A: Sure you can! Here is the manual for mobile users. Q13: When \"unknown wallet error\" pops up on the Poly Bridge page, what shall I do? A: Please check whether the network you connect to is stable by switching nodes of the network. Q14: When I encounter an error submitting an accelerated transaction, what shall I do? A: First of all, please do not submit the accelerated transaction when you encounter an error. Because when the error is shown, the transaction has already been completed on the target chain. Please check the balance in your wallet to see whether you have received your assets. If you have not, please contact Poly Network team. Q15: If my transaction is stuck on the bridge can I cancel the transfer and receive a refund instead? A: All transactions at any stage are IRREVERSIBLE. If your transaction is stuck or takes a long time to arrive, please refer to Q5 and Q6. Q16: If I have not applied Poly Bridge frontend to process my transaction and can’t receive my assets, what shall I do? A: Firstly, please make sure you have paid enough fee to Poly Bridge, and you can check it by calling the \"get fee\" api. If you haven’t paid enough fee, it is recommended that you use the acceleration function to speed up the target chain transaction. Secondly, if you have already paid enough fee or tried to accelerate but the transaction still fails, please contact Poly Network team. Q17: When migrating funds to or from ETH, why is the fee so high? A: Ethereum’s high gas fee has been a concern for many, and is a key hurdle in the platform’s scaling ability. The fee is not generated by Poly Bridge and solely depends on ethereum. Copyright © 2022 PolyNetwork. All right reserved.Last modification date： 2022-03-23 14:52:12 "}}